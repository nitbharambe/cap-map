Index: cap/pfa.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nCode to be refined a lot later on\r\nTODO: Add default values of all functions\r\n\"\"\"\r\n\r\n# Import the pandapower and the networks module:\r\nimport pandapower as pp\r\nimport simbench as sb\r\nimport pandas as pd\r\nimport numpy as np\r\nimport os\r\nimport tempfile\r\nfrom pandapower.timeseries import OutputWriter\r\nfrom pandapower.timeseries.run_time_series import run_timeseries\r\nfrom pandapowermod.timeseries.run_time_series_mod import run_timeseries_mod\r\nfrom pandapowermod.timeseries.run_time_series_mod1 import run_timeseries_mod1\r\n\r\n\r\ndef get_init_all(net):\r\n    \"\"\"\r\n    Returns initialization data for net\r\n    INPUT:\r\n        net : pandapower net\r\n    OUTPUT:\r\n        tuple of initial load, initial generation\r\n    \"\"\"\r\n    initload = net.load[['p_mw', 'q_mvar']]\r\n    initsgen = net.sgen[['p_mw', 'q_mvar']]\r\n    return initload, initsgen\r\n\r\n\r\ndef init_net(net, init_all):\r\n    \"\"\"\r\n    Drops any added load/generation Initialization of load and generation p_mw and q_mvar is needed because the\r\n    run_timeseries replaces them after every iteration Drops Constcontrol objects created by sb.apply_cost_controllers\r\n\r\n    OUTPUT -\r\n        net- Pandapower network with initial values\r\n    \"\"\"\r\n    [initload, initsgen] = init_all\r\n    net.load = net.load.head(len(initload))\r\n    net.sgen = net.sgen.head(len(initsgen))\r\n    net.load[['p_mw', 'q_mvar']] = initload\r\n    net.sgen[['p_mw', 'q_mvar']] = initsgen\r\n    net.controller = net.controller.iloc[0:0]\r\n    return net\r\n\r\n\r\ndef define_log(net, time_steps):\r\n    \"\"\"\r\n    Creates output writer object required for timeseries simulation\r\n    The timeseries module only calculates the values of variables mentioned here for each simulation.\r\n    The temporary data gets stored in the output_dir directory\r\n\r\n    OUTPUT\r\n        ow - Output writer object\r\n    \"\"\"\r\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".json\")\r\n    ow.log_variable('res_bus', 'vm_pu')\r\n    ow.log_variable('res_line', 'loading_percent')\r\n    ow.log_variable('res_trafo', 'loading_percent')\r\n    return ow\r\n\r\n\r\ndef add_loadgen(net_t, loadorgen, conn_at_bus, size_p, size_q, prof):\r\n    \"\"\"\r\n    Adds a load or generation to the net.load or net.sgen table.\r\n    Adds profile name to the profiles variable of the newly addded capacity.\r\n\r\n    INPUT\r\n        net_t (PP net) - Pandapower net\r\n        loadorgen (str) - 'sgen' or 'load' for generation or load for additional capacity connected\r\n        conn_at_bus (int) - Bus at which additional capacity is connected\r\n        prof (str) - Name of the profile. Must be available in the net.profiles of the input grid\r\n\r\n    OUTPUT\r\n        net_t (PP net) - Updated Pandapower net\r\n\r\n    \"\"\"\r\n    if loadorgen == \"load\":\r\n        pp.create_load(net_t, conn_at_bus, p_mw=size_p, q_mvar=size_q)\r\n        net_t.load.tail(1).profile = prof\r\n    elif loadorgen == \"sgen\":\r\n        pp.create_sgen(net_t, conn_at_bus, p_mw=size_p, q_mvar=size_q)\r\n        net_t.sgen.tail(1).profile = prof\r\n    else:\r\n        return 0\r\n    return net_t\r\n\r\n\r\ndef load_files():\r\n    \"\"\"\r\n    Loads files of previous TS simulation\r\n\r\n    OUTPUT\r\n        vm_pu,line_load,trafo_load (tuple) - Previous results of timeseries\r\n    \"\"\"\r\n    vm_pu_file = os.path.join(output_dir, \"res_bus\", \"vm_pu.json\")\r\n    vm_pu = pd.read_json(vm_pu_file)\r\n    line_load_file = os.path.join(output_dir, \"res_line\", \"loading_percent.json\")\r\n    line_load = pd.read_json(line_load_file)\r\n    trafo_load_file = os.path.join(output_dir, \"res_trafo\", \"loading_percent.json\")\r\n    trafo_load = pd.read_json(trafo_load_file)\r\n    return vm_pu, line_load, trafo_load\r\n\r\n\r\ndef violations_long(net):\r\n    \"\"\"\r\n    Checks for any violations created in the grid by additional capacity and returns tuple with the details Loads the\r\n    files created by timeseries simulation. Compares simulation values against the limits mentioned in the input grid.\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n\r\n    OUTPUT\r\n        check (bool) - tuple of violations with details\r\n\r\n    \"\"\"\r\n    [vm_pu, line_load, trafo_load] = load_files()\r\n\r\n    pf_vm_extremes = pd.DataFrame(vm_pu.max())\r\n    pf_vm_extremes.columns = ['pf_max_vm_pu']\r\n    pf_vm_extremes['pf_min_vm_pu'] = vm_pu.min()\r\n    vm_pu_check = net.bus[['name', 'vn_kv', 'min_vm_pu', 'max_vm_pu']].join(pf_vm_extremes)\r\n    vm_pu_check = vm_pu_check[\r\n        (vm_pu_check.pf_max_vm_pu > vm_pu_check.max_vm_pu) | (vm_pu_check.pf_min_vm_pu < vm_pu_check.min_vm_pu)]\r\n\r\n    pf_line_extremes = pd.DataFrame(line_load.max())\r\n    pf_line_extremes.columns = ['pf_max_loading_percent']\r\n    line_load_check = net.line[['name', 'from_bus', 'to_bus', 'max_loading_percent']].join(pf_line_extremes)\r\n    line_load_check = line_load_check[(line_load_check.pf_max_loading_percent > line_load_check.max_loading_percent)]\r\n\r\n    pf_trafo_extremes = pd.DataFrame(trafo_load.max())\r\n    pf_trafo_extremes.columns = ['pf_max_loading_percent']\r\n    trafo_load_check = net.trafo[['name', 'sn_mva', 'max_loading_percent']].join(pf_trafo_extremes)\r\n    trafo_load_check = trafo_load_check[\r\n        (trafo_load_check.pf_max_loading_percent > trafo_load_check.max_loading_percent)]\r\n\r\n    return vm_pu_check, line_load_check, trafo_load_check\r\n\r\n\r\ndef violations(net):\r\n    \"\"\"\r\n    Checks for any violations created in the grid by additional capacity. Loads the files created by timeseries\r\n    simulation. Compares simulation values against the limits mentioned in the input grid.\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n\r\n    OUTPUT\r\n        check (bool) - 'True' for no violations. 'False' for violations present\r\n\r\n    \"\"\"\r\n    [vm_pu, line_load, trafo_load] = load_files()\r\n\r\n    check = any(np.where(vm_pu.max() > net.bus['max_vm_pu'], True, False))\r\n    check = check or any(np.where(vm_pu.min() < net.bus['min_vm_pu'], True, False))\r\n    check = check or any(np.where(line_load.max() > net.line['max_loading_percent'], True, False))\r\n    check = check or any(np.where(trafo_load.max() > net.trafo['max_loading_percent'], True, False))\r\n    return not check\r\n\r\n\r\ndef feas_chk(net, ow, conn_at_bus, loadorgen, size_p, size_q, prof):\r\n    \"\"\"\r\n    Initializes the PPnet,\r\n    Adds additional capacity,\r\n    applies load/generation profiles on all the grid elements,\r\n    runs timeseries for the specific case and save the results in the temporary output directory,\r\n    Checks for violations\r\n\r\n    TODO: Need to check process of how profiles from simbench are actually getting applied to Constcontrol know the\r\n        fix. Also will lead to finding how profiles from input will be applied on the input grid.\r\n    TODO: suppress/workaround printing of individual progress bars\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        ow (Object) - Output writer object\r\n        loadorgen (str) - 'sgen' or 'load' for generation or load for additional capacity connected\r\n        conn_at_bus (int) - Bus at which additional capacity is connected\r\n        size_p (int) - Size of active power of additional capacity\r\n        size_q (int) - Size of reactive power of additional capacity\r\n        prof (str) - Name of the profile. Must be available in the net.profiles of the input grid\r\n\r\n    OUTPUT\r\n        feas_result (bool) - 'True' for feasible, 'False' for not feasible\r\n\r\n    \"\"\"\r\n    init_all = get_init_all(net)\r\n    net = add_loadgen(net, loadorgen, conn_at_bus, size_p, size_q, prof)\r\n    profiles = sb.get_absolute_values(net, profiles_instead_of_study_cases=True)\r\n    sb.apply_const_controllers(net, profiles)  # create timeseries data from profiles and run powerflow\r\n    run_timeseries(net, time_steps, continue_on_divergence=True, verbose=True)  # Run powerflow only over time_steps\r\n    feas_result = violations(net)\r\n    net = init_net(net, init_all)\r\n    return feas_result\r\n\r\n\r\ndef feas_chk_mod(net, conn_at_bus, loadorgen, size_p, size_q, prof):\r\n    \"\"\"\r\n    Same as feas_chk but implements modified run_timeseries function of panadapower to skip unecessary steps.\r\n    \"\"\"\r\n    init_all = get_init_all(net)\r\n    net = add_loadgen(net, loadorgen, conn_at_bus, size_p, size_q, prof)\r\n    profiles = sb.get_absolute_values(net, profiles_instead_of_study_cases=True)\r\n    sb.apply_const_controllers(net, profiles)  # create timeseries data from profiles and run powerflow\r\n    chk = not run_timeseries_mod(net, time_steps, continue_on_divergence=True, verbose=True)  # Run powerflow only over time_steps\r\n    net = init_net(net, init_all)\r\n    return chk\r\n\r\n\r\ndef max_cap(net, ow, conn_at_bus, loadorgen, ul_p, ll_p, prof):\r\n    \"\"\"\r\n    Seach algorithm using feas_chk function over the range of ll_p and ul_p capacities\r\n\r\n    TODO: Speed up, if it is required, try changing ul_p and ll_p as per voltage levels\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        ow (Object) - Output writer object\r\n        loadorgen (str) - 'sgen' or 'load' for generation or load for additional capacity connected\r\n        conn_at_bus (int) - Bus at which additional capacity is connected\r\n        ll_p (int) - Size of maximum power limit of additional capacity that can be added\r\n        ul_p (int) - Size of minimum additional capacity that can be added (Set as 0)\r\n        prof (str) - Name of the profile. Must be available in the net.profiles of the input grid\r\n\r\n    OUTPUT\r\n         (int) - Maximum capacitiy of load/generation that can be added at given bus\r\n\r\n    \"\"\"\r\n    no_iter = 0\r\n    [ul_chk, mid_chk, ll_chk] = False, False, False\r\n    while not (((ul_p - ll_p) < s_tol) | (ul_chk & mid_chk) | (no_iter > 7)):\r\n        no_iter = no_iter + 1\r\n        mid_p = (ul_p + ll_p) / 2\r\n        ul_chk = feas_chk_mod(net, ow, conn_at_bus, loadorgen, size_p=ul_p, size_q=inp_q, prof=prof)\r\n        mid_chk = feas_chk_mod(net, ow, conn_at_bus, loadorgen, size_p=mid_p, size_q=inp_q, prof=prof)\r\n        if mid_chk:\r\n            ll_p = mid_p\r\n        elif not mid_chk:\r\n            ul_p = mid_p\r\n        elif ul_chk:\r\n            return ul_p\r\n    return ll_p\r\n\r\n\r\n'''\r\ndef printProgressBar(iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = \"\\r\"):\r\n    \"\"\"\r\n    https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console\r\n    \r\n    Call in a loop to create terminal progress bar\r\n    @params:\r\n        iteration   - Required  : current iteration (Int)\r\n        total       - Required  : total iterations (Int)\r\n        prefix      - Optional  : prefix string (Str)\r\n        suffix      - Optional  : suffix string (Str)\r\n        decimals    - Optional  : positive number of decimals in percent complete (Int)\r\n        length      - Optional  : character length of bar (Int)\r\n        fill        - Optional  : bar fill character (Str)\r\n        printEnd    - Optional  : end character (e.g. \"\\r\", \"\\r\\n\") (Str)\r\n    \"\"\"\r\n    percent = (\"{0:.\" + str(decimals) + \"f}\").format(100 * (iteration / float(total)))\r\n    filledLength = int(length * iteration // total)\r\n    bar = fill * filledLength + '-' * (length - filledLength)\r\n    print(f'\\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)\r\n    # Print New Line on Complete\r\n    if iteration == total: \r\n        print()\r\n'''\r\n\r\n\r\ndef printProgressBar(iteration, total, prefix='', suffix='', decimals=1, length=100, fill='█'):\r\n    \"\"\"\r\n    Call in a loop to create terminal progress bar.\r\n    the code is mentioned in : https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console\r\n    \"\"\"\r\n    percent = (\"{0:.\" + str(decimals) + \"f}\").format(100 * (iteration / float(total)))\r\n    filled_length = int(length * iteration // total)\r\n    bar = fill * filled_length + '-' * (length - filled_length)\r\n    # logger.info('\\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix))\r\n    print('\\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end=\"\")\r\n    # Print New Line on Complete\r\n    if iteration == total:\r\n        print(\"\\n\")\r\n\r\n\r\ndef all_cap_map(net, ow, loadorgen, ul_p, ll_p, prof):\r\n    \"\"\"\r\n    Iteratre the max_cap function over all busses in the grid.\r\n\r\n    TODO: Add progess bar\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        ow (Object) - Output writer object\r\n        loadorgen (str) - 'sgen' or 'load' for generation or load for additional capacity connected\r\n        ll_p (int) - Size of maximum power limit of additional capacity that can be added\r\n        ul_p (int) - Size of minimum additional capacity that can be added (Set as 0)\r\n        prof (str) - Name of the profile. Must be available in the net.profiles of the input grid\r\n\r\n    OUTPUT allcap (dataframe) - Maximum capacitiy of load/generation that can be added at all buses\r\n    \"\"\"\r\n    len_items = len(net.bus)\r\n    items = list(range(0, len_items))\r\n    printProgressBar(0, len_items, prefix='Progress:', suffix='Complete', length=50)\r\n\r\n    allcap = net.bus[['name', 'vn_kv']]\r\n    allcap = allcap.join(pd.DataFrame(np.zeros([len(net.bus),len(net.line)])))\r\n    for i, conn_at_bus in enumerate(items):\r\n        for out_line in net.line.index:\r\n            net.line.loc[out_line, \"in_service\"] = False\r\n            allcap[out_line][conn_at_bus] = max_cap(net, ow=ow, conn_at_bus=conn_at_bus, loadorgen=loadorgen, ul_p=ul_p, ll_p=ll_p,\r\n                                 prof=prof)\r\n            net.line.loc[out_line, \"in_service\"] = True\r\n    printProgressBar(i + 1, len_items, prefix='Progress:', suffix='Complete', length=50)\r\n    return allcap\r\n\r\n\r\ndef sing_res(net, ow, conn_at_bus, loadorgen, size_p, size_q, prof):\r\n    \"\"\"\r\n    Same as feas_chk. Only difference is that instead of returning bool it returns tuple with details of violations\r\n\r\n    BUG: More like pending to do. Doesnt work for loads. Need to check process of how profiles from simbench are actually\r\n    getting applied to Constcontrol know the fix. Also will lead to finding how profiles from input will be applied on\r\n    the input grid.\r\n    TODO: This function is incomplete. Hence returns 'True' for now.\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        ow (Object) - Output writer object\r\n        loadorgen (str) - 'sgen' or 'load' for generation or load for additional capacity connected\r\n        conn_at_bus (int) - Bus at which additional capacity is connected\r\n        size_p (int) - Size of active power of additional capacity\r\n        size_q (int) - Size of reactive power of additional capacity\r\n        prof (str) - Name of the profile. Must be available in the net.profiles of the input grid\r\n\r\n    OUTPUT\r\n        result (tuple) - violations details\r\n\r\n    \"\"\"\r\n    #return True\r\n    feas_chk(net=net,ow=ow,conn_at_bus=conn_at_bus,loadorgen=loadorgen, size_p=size_p, size_q=size_q, prof=prof)\r\n    return violations_long(net)\r\n\r\n\r\n\r\ndef resample_profiles(net, freq='H' ,head_values=96):\r\n    \"\"\"\r\n    Resample profiles stored in net.profiles. Better alternative is resample_profiles_month\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        freq (str) - frequency of resampling\r\n        head_values (int) - initial values to be resampled since the net.profiles is too large\r\n\r\n    OUTPUT\r\n        net (PP net) - Updated Pandapower net\r\n\r\n    \"\"\"\r\n    for elm in net.profiles.keys():\r\n        net.profiles[elm] = net.profiles[elm].head(head_values)\r\n        net.profiles[elm].index = pd.to_datetime(\r\n            net.profiles[elm].time)  # pd.date_range(start='1/1/2021',freq='H',periods=len(net.profiles['load']))\r\n        # net.profiles[elm].drop('time', axis=1, inplace=True)\r\n        if all(net.profiles[elm].columns == 'time'):\r\n            net.profiles[elm] = net.profiles[elm].resample(freq).sum()\r\n        else:\r\n            net.profiles[elm] = net.profiles[elm].resample(freq).mean()\r\n    return net\r\n\r\ndef resample_profiles_months(net, month=6):\r\n    \"\"\"\r\n    Resample profiles stored in net.profiles for a paritular month into hours of day.\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        month (int) - month number\r\n\r\n    OUTPUT\r\n        net (PP net) - Updated Pandapower net\r\n\r\n    \"\"\"\r\n    for elm in net.profiles.keys():\r\n        #net.profiles[elm] = net.profiles[elm].groupby()\r\n        net.profiles[elm].index = pd.to_datetime(net.profiles[elm].time, dayfirst=True )\r\n        # pd.date_range(start='1/1/2021',freq='H',periods=len(net.profiles['load']))\r\n        # net.profiles[elm].drop('time', axis=1, inplace=True)\r\n        net.profiles[elm] = net.profiles[elm][net.profiles[elm].index.month == month]\r\n        if all(net.profiles[elm].columns == 'time'):\r\n            net.profiles[elm] = net.profiles[elm].groupby(net.profiles[elm].index.hour).sum()\r\n        else:\r\n            net.profiles[elm] = net.profiles[elm].groupby(net.profiles[elm].index.hour).mean()\r\n        #net.profiles[elm].index = pd.to_datetime(net.profiles[elm].index)\r\n\r\n\r\n    return net\r\n\r\ndef get_profiles(net, new_cap_name, cap_steps=4000, cap_step_size=0.05, pf=0.95,resample_freq='H'):\r\n    \"\"\"\r\n    Second method of calculating capacity map using updated run_time_series function of pandapower repository.\r\n    It joins multiple profiles together and runs a single run_timeseries.\r\n\r\n    INPUT\r\n        net (PP net) - Pandapower net\r\n        new_cap_name (str) - same as loadorgen. type of capacity to add at a bus.\r\n        cap_steps (int) - number of profiles to be joined together\r\n        cap_step_size (int) - increment of each cap step which are to be joined.\r\n        pf (int) - power factor\r\n        resample_freq (str) - resampling frequency given to resample function\r\n\r\n    OUTPUT\r\n        profiles (tuple) - profiles to be loaded before run_timeseries. (For application of pandapower controller)\r\n\r\n    \"\"\"\r\n    length_of_profiles = len(net.profiles['load'])\r\n    profiles = sb.get_absolute_values(net, profiles_instead_of_study_cases=True)\r\n    # profiles=[profile[type]*0.05 for type in profiles]\r\n    for type in profiles:\r\n        profiles[type] = pd.concat([profiles[type]] * cap_steps)\r\n        profiles[type].index = pd.date_range(profiles[type].index[0], periods=len(profiles[type]), freq=resample_freq)\r\n    df = pd.Series(range(length_of_profiles * cap_steps))\r\n    df1 = pd.Series(range(length_of_profiles))\r\n    df_add = ((df - pd.concat([df1] * cap_steps, ignore_index=True)) * cap_step_size / length_of_profiles)\r\n    if new_cap_name == 'load':\r\n        df_add.index = profiles['load', 'p_mw'].index\r\n        profiles['load', 'p_mw'].iloc[:, -1] *= df_add\r\n        profiles['load', 'q_mw'].iloc[:, -1] *= df_add * ((1- pf*pf)**0.5)\r\n    elif new_cap_name == 'sgen':\r\n        df_add.index = profiles['sgen', 'p_mw'].index\r\n        profiles['sgen', 'p_mw'].iloc[:, -1] *= df_add\r\n    for elm in profiles:\r\n        profiles[elm].reset_index(inplace=True, drop=True)\r\n    return profiles\r\n\r\n\r\ndef max_cap_map_new(net, loadorgen, conn_at_bus, prof, cap_steps=4000, cap_step_size=0.05, resample_freq='H', head_values_profiles=96):\r\n    \"\"\"\r\n    Same as max_cap but works on the second method which joins same profiles together and runs a single timeseries instead of nested loops as in original method.\r\n    Each profile joined has increased incremental capacity of cap_step_size on the conn_at_bus\r\n    The single timeseries gets interrupted when violation occurs.\r\n    Inputs/output similar to get_profiles and max_cap\r\n\r\n\r\n    \"\"\"\r\n    elm_day = pd.Timedelta('1D') / pd.Timedelta(str(1) + resample_freq)\r\n    init_all = get_init_all(net)\r\n    net = add_loadgen(net, loadorgen, conn_at_bus=conn_at_bus, prof=prof, size_p=1, size_q=1)\r\n    #net=resample_profiles(net, freq=resample_freq, head_values=head_values_profiles)\r\n    profiles = get_profiles(net, new_cap_name=loadorgen, cap_steps=cap_steps, cap_step_size=cap_step_size, resample_freq=resample_freq)\r\n    sb.apply_const_controllers(net, profiles)  # create timeseries data from profiles and run powerflow\r\n    violation_at_step = run_timeseries_mod(net, continue_on_divergence=False,\r\n                                          verbose=True)  # Run powerflow only over time_steps\r\n    net=init_net(net, init_all)\r\n    max_calc = (violation_at_step - violation_at_step % elm_day) * cap_step_size / elm_day\r\n    return max_calc\r\n\r\n\r\ndef max_cap_map_new_cont(net, loadorgen, conn_at_bus, prof, cap_steps=100, cap_step_size=0.1, resample_freq='H', head_values_profiles=96):\r\n    \"\"\"\r\n    Same as max_cap_map_new with contringency analysis.\r\n    \"\"\"\r\n    elm_day = pd.Timedelta('1D') / pd.Timedelta(str(1) + resample_freq)\r\n    min_violation_step=elm_day*cap_steps\r\n    for out_line in net.line.index:\r\n        net.line.loc[out_line, \"in_service\"] = False\r\n        init_all = get_init_all(net)\r\n        net = add_loadgen(net, loadorgen, conn_at_bus=conn_at_bus, prof=prof, size_p=1, size_q=1)\r\n        #net=resample_profiles(net, freq=resample_freq, head_values=head_values_profiles)\r\n        profiles = get_profiles(net, new_cap_name=loadorgen, cap_steps=cap_steps, cap_step_size=cap_step_size, resample_freq=resample_freq)\r\n        sb.apply_const_controllers(net, profiles)  # create timeseries data from profiles and run powerflow\r\n        violation_at_step = run_timeseries_mod(net, continue_on_divergence=False,\r\n                                              verbose=True)  # Run powerflow only over time_steps\r\n        net = init_net(net, init_all)\r\n        if violation_at_step < min_violation_step:\r\n            min_violation_step = violation_at_step\r\n        net.line.loc[out_line, \"in_service\"] = True\r\n    return (min_violation_step - min_violation_step % elm_day) * cap_step_size / elm_day\r\n\r\n\r\ndef all_cap_new(net,loadorgen,prof):\r\n    \"\"\"\r\n    Looping max_cap_map_new_cont over all bus\r\n    \"\"\"\r\n    allcap = net.bus[['name', 'vn_kv']]\r\n    col_name = 'max_add_'+loadorgen\r\n    allcap[col_name] = np.nan\r\n    for i in range(97, len(net.bus)):\r\n        allcap[col_name][i] = max_cap_map_new_cont(net, conn_at_bus=i, loadorgen=loadorgen, prof=prof)\r\n    return allcap\r\n\r\n\r\n\r\nll_p = 0\r\nul_p = 90\r\ninp_q = 0.1\r\ns_tol = 0.005\r\ntime_steps = range(24)\r\n\r\noutput_dir = os.path.join(tempfile.gettempdir(), \"simp_cap_v3\")\r\n# output_dir = os.path.join('C:\\\\Users\\\\nitbh\\\\OneDrive\\\\Documents\\\\IIPNB', \"simp_cap_v3\")\r\nif not os.path.exists(output_dir):\r\n    os.mkdir(output_dir)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cap/pfa.py b/cap/pfa.py
--- a/cap/pfa.py	
+++ b/cap/pfa.py	
@@ -243,12 +243,13 @@
     return ll_p
 
 
-'''
+
 def printProgressBar(iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = "\r"):
     """
     https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console
     
     Call in a loop to create terminal progress bar
+    TODO Progress bar from stackoverflow. Not added to program.
     @params:
         iteration   - Required  : current iteration (Int)
         total       - Required  : total iterations (Int)
@@ -266,22 +267,6 @@
     # Print New Line on Complete
     if iteration == total: 
         print()
-'''
-
-
-def printProgressBar(iteration, total, prefix='', suffix='', decimals=1, length=100, fill='█'):
-    """
-    Call in a loop to create terminal progress bar.
-    the code is mentioned in : https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console
-    """
-    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
-    filled_length = int(length * iteration // total)
-    bar = fill * filled_length + '-' * (length - filled_length)
-    # logger.info('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix))
-    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end="")
-    # Print New Line on Complete
-    if iteration == total:
-        print("\n")
 
 
 def all_cap_map(net, ow, loadorgen, ul_p, ll_p, prof):
@@ -302,7 +287,7 @@
     """
     len_items = len(net.bus)
     items = list(range(0, len_items))
-    printProgressBar(0, len_items, prefix='Progress:', suffix='Complete', length=50)
+    #printProgressBar(0, len_items, prefix='Progress:', suffix='Complete', length=50)
 
     allcap = net.bus[['name', 'vn_kv']]
     allcap = allcap.join(pd.DataFrame(np.zeros([len(net.bus),len(net.line)])))
@@ -312,7 +297,8 @@
             allcap[out_line][conn_at_bus] = max_cap(net, ow=ow, conn_at_bus=conn_at_bus, loadorgen=loadorgen, ul_p=ul_p, ll_p=ll_p,
                                  prof=prof)
             net.line.loc[out_line, "in_service"] = True
-    printProgressBar(i + 1, len_items, prefix='Progress:', suffix='Complete', length=50)
+    #printProgressBar(i + 1, len_items, prefix='Progress:', suffix='Complete', length=50)
+    allcap.to_csv('sampdata/' + datetime.now().strftime("%Y_%m_%d_%H%M%S") + '_allcap.csv')
     return allcap
 
 
@@ -489,7 +475,16 @@
     return allcap
 
 
-
+'''
+time_steps:Set time steps in range for the timeseries module to compute over. 
+    This parameter must be of same length as the length of profiles.
+ll_p and ul_p : limits for maximum and minimum capacity that can be added to any bus
+inp_q: input reactive power for added capacity. Assumed constant
+s_tol: Search algorithm tolerance (in MW)
+output_dir : Set directory for storing the logged varaiables. 
+    Commented output_dir line is for setting directory in the temporary files of the computer.
+ow: Create the output writer object ow
+'''
 ll_p = 0
 ul_p = 90
 inp_q = 0.1
Index: cap/viz.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python\r\n# coding: utf-8\r\n\r\n# My note (Joe):\r\n# 1. fixed the graph function for general users (run through all the data)\r\n\r\n# ### 1. preprocessing the data\r\n\r\n# In[5]:\r\n\r\n\r\n# power flow package & python package ( edited by Joe )\r\nfrom cap import pfa\r\nimport copy\r\nimport pandas as pd\r\n\r\n# Dash import\r\nimport pandas as pd\r\nimport plotly.express as px  # (version 4.7.0)\r\nimport plotly.graph_objects as go\r\n\r\nimport dash  # (version 1.12.0) pip install dash\r\nimport dash_core_components as dcc\r\nimport dash_html_components as html\r\nfrom dash.dependencies import Input, Output\r\n\r\n# panda package\r\nfrom pandapower.plotting.plotly import pf_res_plotly\r\nimport numpy as np\r\n\r\n# for copy panda object\r\nfrom copy import deepcopy\r\n\r\n# for editing the draw_trace() function\r\nfrom pandapower.plotting.plotly import traces\r\nfrom pandapower.plotting.plotly.traces import _in_ipynb\r\n\r\nimport math\r\n\r\nfrom packaging import version\r\nfrom collections.abc import Iterable\r\n\r\nfrom pandapower.plotting.plotly.get_colors import get_plotly_color, get_plotly_cmap\r\nfrom pandapower.plotting.plotly.mapbox_plot import _on_map_test, _get_mapbox_token,     MapboxTokenMissing\r\n\r\ntry:\r\n    from plotly import __version__ as plotly_version\r\n    from plotly.graph_objs.scatter.marker import ColorBar\r\n    from plotly.graph_objs import Figure, Layout\r\n    from plotly.graph_objs.layout import XAxis, YAxis\r\n    from plotly.graph_objs.scatter import Line, Marker\r\n    from plotly.graph_objs.scattermapbox import Line as scmLine\r\n    from plotly.graph_objs.scattermapbox import Marker as scmMarker\r\nexcept ImportError:\r\n    logger.info(\"Failed to import plotly - interactive plotting will not be available\")\r\n\r\n# changing the function part (edited by Daniel)\r\n# import pandas as pd \r\nfrom pandapower.plotting.generic_geodata import create_generic_coordinates\r\nfrom pandapower.plotting.plotly.mapbox_plot import *\r\nfrom pandapower.plotting.plotly.traces import create_bus_trace, create_line_trace,     create_trafo_trace, draw_traces, version_check\r\nfrom pandapower.run import runpp\r\n \r\ntry:\r\n    import pplog as logging\r\nexcept ImportError:\r\n    import logging\r\nlogger = logging.getLogger(__name__)\r\n\r\n\r\n# In[2]:\r\n\r\n\r\n# Edited function res_plotly() and draw_traces()\r\n\r\ndef draw_traces_nograph(traces, on_map=False, map_style='basic', showlegend=True, figsize=1,\r\n                aspectratio='auto', filename='temp-plot.html'):\r\n    \"\"\"\r\n    plots all the traces (which can be created using :func:`create_bus_trace`, :func:`create_line_trace`,\r\n    :func:`create_trafo_trace`)\r\n    to PLOTLY (see https://plot.ly/python/)\r\n\r\n    INPUT:\r\n        **traces** - list of dicts which correspond to plotly traces\r\n        generated using: `create_bus_trace`, `create_line_trace`, `create_trafo_trace`\r\n\r\n    OPTIONAL:\r\n        **on_map** (bool, False) - enables using mapbox plot in plotly\r\n\r\n        **map_style** (str, 'basic') - enables using mapbox plot in plotly\r\n\r\n            - 'streets'\r\n            - 'bright'\r\n            - 'light'\r\n            - 'dark'\r\n            - 'satellite'\r\n\r\n        **showlegend** (bool, 'True') - enables legend display\r\n\r\n        **figsize** (float, 1) - aspectratio is multiplied by it in order to get final image size\r\n\r\n        **aspectratio** (tuple, 'auto') - when 'auto' it preserves original aspect ratio of the\r\n            network geodata any custom aspectration can be given as a tuple, e.g. (1.2, 1)\r\n\r\n        **filename** (str, \"temp-plot.html\") - plots to a html file called filename\r\n\r\n    OUTPUT:\r\n        **figure** (graph_objs._figure.Figure) figure object\r\n\r\n    \"\"\"\r\n\r\n    if on_map:\r\n        try:\r\n            on_map = _on_map_test(traces[0]['x'][0], traces[0]['y'][0])\r\n        except:\r\n            logger.warning(\"Test if geo-data are in lat/long cannot be performed using geopy -> \"\r\n                           \"eventual plot errors are possible.\")\r\n\r\n        if on_map is False:\r\n            logger.warning(\"Existing geodata are not real lat/lon geographical coordinates. -> \"\r\n                           \"plot on maps is not possible.\\n\"\r\n                           \"Use geo_data_to_latlong(net, projection) to transform geodata from specific projection.\")\r\n\r\n    if on_map:\r\n        # change traces for mapbox\r\n        # change trace_type to scattermapbox and rename x to lat and y to lon\r\n        for trace in traces:\r\n            trace['lat'] = trace.pop('x')\r\n            trace['lon'] = trace.pop('y')\r\n            trace['type'] = 'scattermapbox'\r\n            if \"line\" in trace and isinstance(trace[\"line\"], Line):\r\n                # scattermapboxplot lines do not support dash for some reason, make it a red line instead\r\n                if \"dash\" in trace[\"line\"]._props:\r\n                    _prps = dict(trace[\"line\"]._props)\r\n                    _prps.pop(\"dash\", None)\r\n                    _prps[\"color\"] = \"red\"\r\n                    trace[\"line\"] = scmLine(_prps)\r\n                else:\r\n                    trace[\"line\"] = scmLine(dict(trace[\"line\"]._props))\r\n            elif \"marker\" in trace and isinstance(trace[\"marker\"], Marker):\r\n                trace[\"marker\"] = scmMarker(trace[\"marker\"]._props)\r\n\r\n    # setting Figure object\r\n    fig = Figure(data=traces,  # edge_trace\r\n                 layout=Layout(\r\n                     titlefont=dict(size=16),\r\n                     showlegend=showlegend,\r\n                     autosize=(aspectratio == 'auto'),\r\n                     hovermode='closest',\r\n                     margin=dict(b=5, l=5, r=5, t=5),\r\n                     # annotations=[dict(\r\n                     #     text=\"\",\r\n                     #     showarrow=False,\r\n                     #     xref=\"paper\", yref=\"paper\",\r\n                     #     x=0.005, y=-0.002)],\r\n                     xaxis=XAxis(showgrid=False, zeroline=False, showticklabels=False),\r\n                     yaxis=YAxis(showgrid=False, zeroline=False, showticklabels=False),\r\n                     # legend=dict(x=0, y=1.0)\r\n                 ), )\r\n\r\n    # check if geodata are real geographical lat/lon coordinates using geopy\r\n\r\n    if on_map:\r\n        try:\r\n            mapbox_access_token = _get_mapbox_token()\r\n        except Exception:\r\n            logger.exception('mapbox token required for map plots. '\r\n                             'Get Mapbox token by signing in to https://www.mapbox.com/.\\n'\r\n                             'After getting a token, set it to pandapower using:\\n'\r\n                             'pandapower.plotting.plotly.mapbox_plot.set_mapbox_token(\\'<token>\\')')\r\n            raise MapboxTokenMissing\r\n\r\n        fig['layout']['mapbox'] = dict(accesstoken=mapbox_access_token,\r\n                                       bearing=0,\r\n                                       center=dict(lat=pd.Series(traces[0]['lat']).dropna().mean(),\r\n                                                   lon=pd.Series(traces[0]['lon']).dropna().mean()),\r\n                                       style=map_style,\r\n                                       pitch=0,\r\n                                       zoom=11)\r\n\r\n    # default aspectratio: if on_map use auto, else use 'original'\r\n    aspectratio = 'original' if not on_map and aspectratio == 'auto' else aspectratio\r\n\r\n    if aspectratio != 'auto':\r\n        if aspectratio == 'original':\r\n            # TODO improve this workaround for getting original aspectratio\r\n            xs = []\r\n            ys = []\r\n            for trace in traces:\r\n                xs += trace['x']\r\n                ys += trace['y']\r\n            x_dropna = pd.Series(xs).dropna()\r\n            y_dropna = pd.Series(ys).dropna()\r\n            xrange = x_dropna.max() - x_dropna.min()\r\n            yrange = y_dropna.max() - y_dropna.min()\r\n            ratio = xrange / yrange\r\n            if ratio < 1:\r\n                aspectratio = (ratio, 1.)\r\n            else:\r\n                aspectratio = (1., 1 / ratio)\r\n\r\n        aspectratio = np.array(aspectratio) / max(aspectratio)\r\n        fig['layout']['width'], fig['layout']['height'] = ([ar * figsize * 700 for ar in aspectratio])\r\n\r\n    # check if called from ipynb or not in order to consider appropriate plot function\r\n    if _in_ipynb():\r\n        from plotly.offline import init_notebook_mode, iplot as plot\r\n        init_notebook_mode()\r\n    else:\r\n        from plotly.offline import plot as plot\r\n\r\n    # delete the plot function here.\r\n    # plot(fig, filename=filename)\r\n\r\n    return fig\r\n\r\n# Generating the plot for GENERAL users of the map\r\n\r\ndef pf_res_plotly_gen(net, capacity_limit, cmap=\"binary_r\", use_line_geodata=None, on_map=False, projection=None,\r\n                  map_style='basic', figsize=1, aspectratio='auto', line_width=2, bus_size=10,\r\n                  climits_volt=(0.9, 1.1), climits_load=(0, 100), cpos_volt=1.0, cpos_load=1.1,\r\n                  filename=\"temp-plot.html\"):\r\n    \"\"\"\r\n    Plots a pandapower network in plotly\r\n    using colormap for coloring lines according to line loading and buses according to voltage in p.u.\r\n    If no geodata is available, artificial geodata is generated. For advanced plotting see the tutorial\r\n \r\n    INPUT:\r\n        **net** - The pandapower format network. If none is provided, mv_oberrhein() will be\r\n        plotted as an example\r\n \r\n    OPTIONAL:\r\n        **respect_switches** (bool, False) - Respect switches when artificial geodata is created\r\n \r\n        *cmap** (str, True) - name of the colormap\r\n \r\n        *colors_dict** (dict, None) - by default 6 basic colors from default collor palette is used.\r\n        Otherwise, user can define a dictionary in the form: voltage_kv : color\r\n \r\n        **on_map** (bool, False) - enables using mapbox plot in plotly\r\n        If provided geodata are not real geo-coordinates in lon/lat form, on_map will be set to False.\r\n \r\n        **projection** (String, None) - defines a projection from which network geo-data will be transformed to\r\n        lat-long. For each projection a string can be found at http://spatialreference.org/ref/epsg/\r\n \r\n        **map_style** (str, 'basic') - enables using mapbox plot in plotly\r\n \r\n            - 'streets'\r\n            - 'bright'\r\n            - 'light'\r\n            - 'dark'\r\n            - 'satellite'\r\n \r\n        **figsize** (float, 1) - aspectratio is multiplied by it in order to get final image size\r\n \r\n        **aspectratio** (tuple, 'auto') - when 'auto' it preserves original aspect ratio of the network geodata\r\n        any custom aspectration can be given as a tuple, e.g. (1.2, 1)\r\n \r\n        **line_width** (float, 1.0) - width of lines\r\n \r\n        **bus_size** (float, 10.0) -  size of buses to plot.\r\n \r\n        **climits_volt** (tuple, (0.9, 1.0)) - limits of the colorbar for voltage\r\n \r\n        **climits_load** (tuple, (0, 100)) - limits of the colorbar for line_loading\r\n \r\n        **cpos_volt** (float, 1.0) - position of the bus voltage colorbar\r\n \r\n        **cpos_load** (float, 1.1) - position of the loading percent colorbar\r\n \r\n        **filename** (str, \"temp-plot.html\") - filename / path to plot to. Should end on *.html\r\n \r\n    OUTPUT:\r\n        **figure** (graph_objs._figure.Figure) figure object\r\n \r\n    \"\"\"\r\n    version_check()\r\n    if 'res_bus' not in net or net.get('res_bus').shape[0] == 0:\r\n        logger.warning('There are no Power Flow results. A Newton-Raphson power flow will be executed.')\r\n        runpp(net)\r\n \r\n    # create geocoord if none are available\r\n    if 'line_geodata' not in net:\r\n        net.line_geodata = pd.DataFrame(columns=['coords'])\r\n    if 'bus_geodata' not in net:\r\n        net.bus_geodata = pd.DataFrame(columns=[\"x\", \"y\"])\r\n    if len(net.line_geodata) == 0 and len(net.bus_geodata) == 0:\r\n        logger.warning(\"No or insufficient geodata available --> Creating artificial coordinates.\" +\r\n                       \" This may take some time\")\r\n        create_generic_coordinates(net, respect_switches=True)\r\n        if on_map:\r\n            logger.warning(\"Map plots not available with artificial coordinates and will be disabled!\")\r\n            on_map = False\r\n \r\n    # check if geodata are real geographycal lat/lon coordinates using geopy\r\n    if on_map and projection is not None:\r\n        geo_data_to_latlong(net, projection=projection)\r\n \r\n    # ----- Buses ------\r\n    # initializating bus trace\r\n    # hoverinfo which contains name and pf results\r\n    precision = 3\r\n    hoverinfo = (\r\n            net.bus.name.astype(str) + '<br />'\r\n            #'V_m = ' + net.res_bus.vm_pu.round(precision).astype(str) + 'pu' + '<br />' +\r\n            #'V_m = ' + (net.res_bus.vm_pu * net.bus.vn_kv.round(2)).round(precision).astype(str) + ' kV' + '<br />' +\r\n            #'V_a = ' + net.res_bus.va_degree.round(precision).astype(str)' +\r\n            'Max_cap =' + net.bus.max_load.astype(str) + 'MW' + '<br />' +\r\n            'cost =' + net.bus.cost.astype(str) + 'SEK/MWh' + '<br />').tolist()\r\n            \r\n    hoverinfo = pd.Series(index=net.bus.index, data=hoverinfo)\r\n\r\n    bus_trace_less = create_bus_trace(net, net.bus[net.bus['max_load']<=capacity_limit].index, size=bus_size, infofunc=hoverinfo, color='red')\r\n    bus_trace_more = create_bus_trace(net, net.bus[net.bus['max_load']>capacity_limit].index, size=bus_size, infofunc=hoverinfo, color='blue')\r\n\r\n    # ----- Lines ------\r\n    # if bus geodata is available, but no line geodata\r\n    # if bus geodata is available, but no line geodata\r\n    cmap_lines = 'binary' if cmap == 'binary' else cmap\r\n    if use_line_geodata is None:\r\n        use_line_geodata = False if len(net.line_geodata) == 0 else True\r\n    elif use_line_geodata and len(net.line_geodata) == 0:\r\n        logger.warning(\"No or insufficient line geodata available --> only bus geodata will be used.\")\r\n        use_line_geodata = False\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (net.line.name.astype(str) + '<br />').tolist()\r\n            #'I = ' + net.res_line.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            #'I_from = ' + net.res_line.i_from_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            #'I_to = ' + net.res_line.i_to_ka.round(precision).astype(str) + ' kA' + '<br />'\r\n            \r\n    hoverinfo = pd.Series(index=net.line.index, data=hoverinfo)\r\n    line_traces = create_line_trace(net, use_line_geodata=use_line_geodata, respect_switches=True,\r\n                                    width=line_width,\r\n                                    infofunc=hoverinfo,\r\n                                    cmap=cmap_lines,\r\n                                    cmap_vals=net.res_line['loading_percent'].values,\r\n                                    cmin=climits_load[1],\r\n                                    cmax=climits_load[1])\r\n                                    #cbar_title='Line Loading [%]',\r\n                                    #cpos=cpos_load)\r\n \r\n    # ----- Trafos ------\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (net.trafo.name.astype(str) + '<br />').tolist()\r\n            #'I = ' + net.res_trafo.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            #'I_hv = ' + net.res_trafo.i_hv_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            #'I_lv = ' + net.res_trafo.i_lv_ka.round(precision).astype(str) + ' kA' + '<br />'\r\n  \r\n    hoverinfo = pd.Series(index=net.trafo.index, data=hoverinfo)\r\n    trafo_traces = create_trafo_trace(net, width=line_width * 1.5, infofunc=hoverinfo,\r\n                                      cmap=cmap_lines, cmin=0, cmax=100)\r\n \r\n    # ----- Ext grid ------\r\n    # get external grid from create_bus_trace\r\n    marker_type = 'circle' if on_map else 'square'\r\n    ext_grid_trace = create_bus_trace(net, buses=net.ext_grid.bus,\r\n                                      color='grey', size=bus_size * 2, trace_name='external_grid',\r\n                                      patch_type=marker_type)\r\n \r\n    return draw_traces_nograph(line_traces + trafo_traces + ext_grid_trace + bus_trace_less + bus_trace_more,\r\n                       showlegend=False, aspectratio=aspectratio, on_map=on_map,\r\n                       map_style=map_style, figsize=figsize, filename=filename)\r\n\r\n# Generating map for the technical users\r\n\r\ndef pf_res_plotly_eng(net, cmap=\"Jet\", use_line_geodata=None, on_map=False, projection=None,\r\n                  map_style='basic', figsize=1, aspectratio='auto', line_width=2, bus_size=10,\r\n                  climits_volt=(0.9, 1.1), climits_load=(0, 100), cpos_volt=1.0, cpos_load=1.1,\r\n                  filename=\"temp-plot.html\"):\r\n    \"\"\"\r\n    Plots a pandapower network in plotly\r\n    using colormap for coloring lines according to line loading and buses according to voltage in p.u.\r\n    If no geodata is available, artificial geodata is generated. For advanced plotting see the tutorial\r\n\r\n    INPUT:\r\n        **net** - The pandapower format network. If none is provided, mv_oberrhein() will be\r\n        plotted as an example\r\n\r\n    OPTIONAL:\r\n        **respect_switches** (bool, False) - Respect switches when artificial geodata is created\r\n\r\n        *cmap** (str, True) - name of the colormap\r\n\r\n        *colors_dict** (dict, None) - by default 6 basic colors from default collor palette is used.\r\n        Otherwise, user can define a dictionary in the form: voltage_kv : color\r\n\r\n        **on_map** (bool, False) - enables using mapbox plot in plotly\r\n        If provided geodata are not real geo-coordinates in lon/lat form, on_map will be set to False.\r\n\r\n        **projection** (String, None) - defines a projection from which network geo-data will be transformed to\r\n        lat-long. For each projection a string can be found at http://spatialreference.org/ref/epsg/\r\n\r\n        **map_style** (str, 'basic') - enables using mapbox plot in plotly\r\n\r\n            - 'streets'\r\n            - 'bright'\r\n            - 'light'\r\n            - 'dark'\r\n            - 'satellite'\r\n\r\n        **figsize** (float, 1) - aspectratio is multiplied by it in order to get final image size\r\n\r\n        **aspectratio** (tuple, 'auto') - when 'auto' it preserves original aspect ratio of the network geodata\r\n        any custom aspectration can be given as a tuple, e.g. (1.2, 1)\r\n\r\n        **line_width** (float, 1.0) - width of lines\r\n\r\n        **bus_size** (float, 10.0) -  size of buses to plot.\r\n\r\n        **climits_volt** (tuple, (0.9, 1.0)) - limits of the colorbar for voltage\r\n\r\n        **climits_load** (tuple, (0, 100)) - limits of the colorbar for line_loading\r\n\r\n        **cpos_volt** (float, 1.0) - position of the bus voltage colorbar\r\n\r\n        **cpos_load** (float, 1.1) - position of the loading percent colorbar\r\n\r\n        **filename** (str, \"temp-plot.html\") - filename / path to plot to. Should end on *.html\r\n\r\n    OUTPUT:\r\n        **figure** (graph_objs._figure.Figure) figure object\r\n\r\n    \"\"\"\r\n    version_check()\r\n    if 'res_bus' not in net or net.get('res_bus').shape[0] == 0:\r\n        logger.warning('There are no Power Flow results. A Newton-Raphson power flow will be executed.')\r\n        runpp(net)\r\n\r\n    # create geocoord if none are available\r\n    if 'line_geodata' not in net:\r\n        net.line_geodata = pd.DataFrame(columns=['coords'])\r\n    if 'bus_geodata' not in net:\r\n        net.bus_geodata = pd.DataFrame(columns=[\"x\", \"y\"])\r\n    if len(net.line_geodata) == 0 and len(net.bus_geodata) == 0:\r\n        logger.warning(\"No or insufficient geodata available --> Creating artificial coordinates.\" +\r\n                       \" This may take some time\")\r\n        create_generic_coordinates(net, respect_switches=True)\r\n        if on_map:\r\n            logger.warning(\"Map plots not available with artificial coordinates and will be disabled!\")\r\n            on_map = False\r\n    for geo_type in [\"bus_geodata\", \"line_geodata\"]:\r\n        dupl_geo_idx = pd.Series(net[geo_type].index)[pd.Series(\r\n                net[geo_type].index).duplicated()]\r\n        if len(dupl_geo_idx):\r\n            if len(dupl_geo_idx) > 20:\r\n                logger.warning(\"In net.%s are %i duplicated \" % (geo_type, len(dupl_geo_idx)) +\r\n                               \"indices. That can cause troubles for draw_traces()\")\r\n            else:\r\n                logger.warning(\"In net.%s are the following duplicated \" % geo_type +\r\n                               \"indices. That can cause troubles for draw_traces(): \" + str(\r\n                               dupl_geo_idx))\r\n\r\n\r\n    # check if geodata are real geographycal lat/lon coordinates using geopy\r\n    if on_map and projection is not None:\r\n        geo_data_to_latlong(net, projection=projection)\r\n\r\n    # ----- Buses ------\r\n    # initializating bus trace\r\n    # hoverinfo which contains name and pf results\r\n    precision = 3\r\n    hoverinfo = (\r\n            net.bus.name.astype(str) + '<br />' +\r\n            'V_m = ' + net.res_bus.vm_pu.round(precision).astype(str) + ' pu' + '<br />' +\r\n            'V_m = ' + (net.res_bus.vm_pu * net.bus.vn_kv.round(2)).round(precision).astype(str) + ' kV' + '<br />' +\r\n            'V_a = ' + net.res_bus.va_degree.round(precision).astype(str) + ' deg'\r\n            'Max_cap =' + net.bus.max_load.astype(str) + 'MW' + '<br />' +\r\n            'cost =' + net.bus.cost.astype(str) + 'SEK/MWh' + '<br />').tolist()\r\n\r\n    hoverinfo = pd.Series(index=net.bus.index, data=hoverinfo)\r\n    bus_trace = create_bus_trace(net, net.bus.index, size=bus_size, infofunc=hoverinfo, cmap=cmap,\r\n                                 cbar_title='Bus Voltage [pu]', cmin=climits_volt[0], cmax=climits_volt[1],\r\n                                 cpos=cpos_volt)\r\n\r\n    # ----- Lines ------\r\n    # if bus geodata is available, but no line geodata\r\n    # if bus geodata is available, but no line geodata\r\n    cmap_lines = 'jet' if cmap == 'Jet' else cmap\r\n    if use_line_geodata is None:\r\n        use_line_geodata = False if len(net.line_geodata) == 0 else True\r\n    elif use_line_geodata and len(net.line_geodata) == 0:\r\n        logger.warning(\"No or insufficient line geodata available --> only bus geodata will be used.\")\r\n        use_line_geodata = False\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (\r\n            net.line.name.astype(str) + '<br />' +\r\n            'I = ' + net.res_line.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            'I_from = ' + net.res_line.i_from_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            'I_to = ' + net.res_line.i_to_ka.round(precision).astype(str) + ' kA' + '<br />').tolist()\r\n    hoverinfo = pd.Series(index=net.line.index, data=hoverinfo)\r\n    line_traces = create_line_trace(net, use_line_geodata=use_line_geodata, respect_switches=True,\r\n                                    width=line_width,\r\n                                    infofunc=hoverinfo,\r\n                                    cmap=cmap_lines,\r\n                                    cmap_vals=net.res_line['loading_percent'].values,\r\n                                    cmin=climits_load[0],\r\n                                    cmax=climits_load[1],\r\n                                    cbar_title='Line Loading [%]',\r\n                                    cpos=cpos_load)\r\n\r\n    # ----- Trafos ------\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (\r\n            net.trafo.name.astype(str) + '<br />' +\r\n            'I = ' + net.res_trafo.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            'I_hv = ' + net.res_trafo.i_hv_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            'I_lv = ' + net.res_trafo.i_lv_ka.round(precision).astype(str) + ' kA' + '<br />').tolist()\r\n    hoverinfo = pd.Series(index=net.trafo.index, data=hoverinfo)\r\n    trafo_traces = create_trafo_trace(net, width=line_width * 1.5, infofunc=hoverinfo,\r\n                                      cmap=cmap_lines, cmin=0, cmax=100)\r\n\r\n    # ----- Ext grid ------\r\n    # get external grid from create_bus_trace\r\n    marker_type = 'circle' if on_map else 'square'\r\n    ext_grid_trace = create_bus_trace(net, buses=net.ext_grid.bus,\r\n                                      color='grey', size=bus_size * 2, trace_name='external_grid',\r\n                                      patch_type=marker_type)\r\n\r\n    return draw_traces_nograph(line_traces + trafo_traces + ext_grid_trace + bus_trace,\r\n                       showlegend=False, aspectratio=aspectratio, on_map=on_map,\r\n                       map_style=map_style, figsize=figsize, filename=filename)\r\n\r\n# In[3]:\r\n\r\n\r\n\r\n\"\"\" \r\n\r\nExtract data from time-series calculation. With result[0] being the vm_pu, result[1] being line_load, result[2] being trafo_loading_percent\r\n\r\nReturn two list, networks & figures. Which will be later used for Dash.\r\n\r\n Some points here: \r\n1. the time series loop through columns instead of rows. This is dealt in the two loop structure down below.\r\n\r\n\"\"\"\r\ndef generate_graph_data_eng(net):\r\n    net = net\r\n    result = pfa.load_files()\r\n\r\n    # create lists for time-series data, networks for net, figures for fig\r\n    networks = [None]*len(result[0])\r\n    figures = [None]*len(result[0])\r\n\r\n    # looping to get the time-series data into the list ( i = number(timeseries) networks)\r\n    for i in np.arange(len(result[0])):\r\n        \r\n        # here iterate through res_bus.vm_pu, ( result[0] )\r\n        for j in np.arange(len(result[0].columns)):\r\n            net.res_bus.vm_pu[j] = result[0][j][i]\r\n        \r\n        # here iterate through res_line.loading_percent, ( result[1] )\r\n        for k in np.arange(len(result[1].columns)):\r\n            net.res_line.loading_percent[k] = result[1][k][i]\r\n        \r\n        # here iterate through res_trafo.loading_percent, ( result[2] )\r\n        for l in np.arange(len(result[2].columns)):\r\n            net.res_trafo.loading_percent[l] = result[2][l][i]\r\n        \r\n        networks[i] = deepcopy(net)\r\n\r\n    #looping to get the time series graph\r\n    for ii in np.arange(len(networks)):\r\n        figures[ii] = deepcopy(pf_res_plotly_eng(networks[ii],map_style='dark'))\r\n       \r\n    return networks, figures\r\n\r\n\"\"\" \r\n\r\nSelecting the most important two graph for general users. \r\nThe function needs to be \" revised \" later on for one more function to determine what is the graph we are going to show.\r\n\r\n\"\"\"\r\ndef generate_graph_data_gen(networks_eng, capacity_limit):\r\n    networks = networks_eng\r\n    figures = [None]*2\r\n\r\n    figures[0] = deepcopy(pf_res_plotly_gen(networks[5],capacity_limit,map_style='dark'))\r\n    ''' Here the pf_res_plotly_eng is only for demo, it should be pf_res_plotly_gen just like the previous line '''\r\n    figures[1] = deepcopy(pf_res_plotly_gen(networks[90],capacity_limit,map_style='dark'))\r\n       \r\n    return figures\r\n\r\n\r\n# ### 2. Generate the grpah with Dash\r\n\r\n# In[4]:\r\n\r\n\r\n\"\"\"\r\n\r\nGenerate Dash graph. Calling this function along is enough for generating the grapgh.\r\n\r\nInput:\r\nshould be with (net_data, time_step)\r\n\r\nOutpuy:\r\nreturn a link to the Dash site.\r\n\r\n\"\"\"\r\n\r\ndef generate_graph(input_data, time):\r\n    net = input_data\r\n    time_steps = time\r\n    \r\n    networks = [None]*len(net.res_bus.vm_pu)\r\n    figures = [None]*len(time_steps)\r\n    # extract time-series values\r\n    networks, figures = generate_graph_data(net)\r\n    \r\n    # take the correct order for slider\r\n    list_length = len(networks)-1\r\n\r\n    app = dash.Dash(__name__)\r\n\r\n    # ------------------------------------------------------------------------------\r\n    # App layout\r\n    app.layout = html.Div([\r\n\r\n        html.H1(\"Capacity Map with Dash component Testing\", style={'text-align': 'center'}),\r\n\r\n        dcc.Dropdown(id=\"slct_year\",\r\n                     options=[\r\n                         {\"label\": \"2015\", \"value\": 2015},\r\n                         {\"label\": \"2016\", \"value\": 2016},\r\n                         {\"label\": \"2017\", \"value\": 2017},\r\n                         {\"label\": \"2018\", \"value\": 2018}],\r\n                     multi=False,\r\n                     value=2015,\r\n                     style={'width': \"40%\"}\r\n                     ),\r\n\r\n        html.Br(),\r\n\r\n        dcc.Graph(id='my_powerFlow_graph',\r\n                  style={\r\n                      \"margin-left\": \"auto\",\r\n                      \"margin-right\": \"auto\",\r\n                  },\r\n                  figure={}),\r\n        html.Div(id='output_container_slider', children=[]),\r\n        html.Br(),\r\n\r\n        dcc.Slider(\r\n            id='my-slider',\r\n            min=0,\r\n            max=list_length,\r\n            step=1,\r\n            value=1,\r\n        ),\r\n\r\n    ],\r\n        # putting Style for the whole html.div block and it works!!!\r\n    style={'width': '50%','padding-left':'25%', 'padding-right':'25%'},\r\n    )\r\n\r\n\r\n    # ------------------------------------------------------------------------------\r\n    # Connect the Plotly graphs with Dash Components\r\n    @app.callback(\r\n        [Output(component_id='output_container_slider', component_property='children'),\r\n         Output(component_id='my_powerFlow_graph', component_property='figure')],\r\n        [Input(component_id='slct_year', component_property='value'),\r\n         Input(component_id = 'my-slider',component_property='value')]\r\n    )\r\n    def update_graph(option_slctd, slider_slctd):\r\n        print(option_slctd)\r\n        print(type(option_slctd))\r\n\r\n        container = \"The year chosen by user was: {}\".format(option_slctd)\r\n        container_slider = \"The time chosen by user was: {}\".format(slider_slctd)\r\n\r\n        fig_power = figures[slider_slctd]\r\n\r\n        # 上面的output對應到這邊的return，是按照順序的\r\n        # The output is correspoding to the return value below, by order\r\n        return container_slider, fig_power\r\n\r\n\r\n    # ------------------------------------------------------------------------------\r\n    if __name__ == '__main__':\r\n        return app.run_server(debug=True,use_reloader=False,port=3004)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cap/viz.py b/cap/viz.py
--- a/cap/viz.py	
+++ b/cap/viz.py	
@@ -544,7 +544,6 @@
 
     # looping to get the time-series data into the list ( i = number(timeseries) networks)
     for i in np.arange(len(result[0])):
-        
         # here iterate through res_bus.vm_pu, ( result[0] )
         for j in np.arange(len(result[0].columns)):
             net.res_bus.vm_pu[j] = result[0][j][i]
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"710cff92-6522-4a5b-b421-90a4e8d4e451\" name=\"Default Changelist\" comment=\"Added .py file along with map from joe\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cap_comb.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cap_comb.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"FlaskConsoleOptions\" custom-start-script=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\">\r\n    <envs>\r\n      <env key=\"FLASK_APP\" value=\"app\" />\r\n    </envs>\r\n    <option name=\"myCustomStartScript\" value=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\" />\r\n    <option name=\"myEnvs\">\r\n      <map>\r\n        <entry key=\"FLASK_APP\" value=\"app\" />\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1q1JM93pNedTSQL4YpobeftfWM4\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../cap-map-main\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"cap_comb\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"cap-map\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/cap_comb.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.cap_comb\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"710cff92-6522-4a5b-b421-90a4e8d4e451\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1616241111635</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1616241111635</updated>\r\n      <workItem from=\"1616241114603\" duration=\"3083000\" />\r\n      <workItem from=\"1616442592511\" duration=\"217000\" />\r\n      <workItem from=\"1616442998541\" duration=\"5356000\" />\r\n      <workItem from=\"1616457289744\" duration=\"6014000\" />\r\n      <workItem from=\"1616542118611\" duration=\"1294000\" />\r\n      <workItem from=\"1617029325339\" duration=\"1708000\" />\r\n      <workItem from=\"1617051185921\" duration=\"3715000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Change output_dir, add results from csv\">\r\n      <created>1616456769405</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1616456769405</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Change output_dir, add results from csv\">\r\n      <created>1616456841285</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1616456841285</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Fix some issues\">\r\n      <created>1616461358999</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1616461358999</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Fix some issues\">\r\n      <created>1616497873173</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1616497873173</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Added .py file along with map from joe\">\r\n      <created>1617062189388</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1617062189388</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"origin/main\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Change output_dir, add results from csv\" />\r\n    <MESSAGE value=\"Fix some issues\" />\r\n    <MESSAGE value=\"Added .py file along with map from joe\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Added .py file along with map from joe\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/cap_map$cap_comb.coverage\" NAME=\"cap_comb Coverage Results\" MODIFIED=\"1617061966686\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="710cff92-6522-4a5b-b421-90a4e8d4e451" name="Default Changelist" comment="Added .py file along with map from joe">
+    <list default="true" id="710cff92-6522-4a5b-b421-90a4e8d4e451" name="Default Changelist" comment="Final update of pfa including second method.">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cap/pfa.py" beforeDir="false" afterPath="$PROJECT_DIR$/cap/pfa.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cap/viz.py" beforeDir="false" afterPath="$PROJECT_DIR$/cap/viz.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/cap_comb.py" beforeDir="false" afterPath="$PROJECT_DIR$/cap_comb.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -87,6 +89,7 @@
       <workItem from="1616542118611" duration="1294000" />
       <workItem from="1617029325339" duration="1708000" />
       <workItem from="1617051185921" duration="3715000" />
+      <workItem from="1622439548128" duration="2523000" />
     </task>
     <task id="LOCAL-00001" summary="Change output_dir, add results from csv">
       <created>1616456769405</created>
@@ -123,11 +126,28 @@
       <option name="project" value="LOCAL" />
       <updated>1617062189388</updated>
     </task>
-    <option name="localTasksCounter" value="6" />
+    <task id="LOCAL-00006" summary="Final update of pfa including second method.">
+      <created>1622439508458</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1622439508458</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
+  </component>
+  <component name="Vcs.Log.History.Properties">
+    <option name="COLUMN_ID_ORDER">
+      <list>
+        <option value="Default.Root" />
+        <option value="Default.Author" />
+        <option value="Default.Date" />
+        <option value="Default.Subject" />
+      </list>
+    </option>
   </component>
   <component name="Vcs.Log.Tabs.Properties">
     <option name="TAB_STATES">
@@ -157,9 +177,11 @@
     <MESSAGE value="Change output_dir, add results from csv" />
     <MESSAGE value="Fix some issues" />
     <MESSAGE value="Added .py file along with map from joe" />
-    <option name="LAST_COMMIT_MESSAGE" value="Added .py file along with map from joe" />
+    <MESSAGE value="Final update of pfa including second method." />
+    <option name="LAST_COMMIT_MESSAGE" value="Final update of pfa including second method." />
   </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
-    <SUITE FILE_PATH="coverage/cap_map$cap_comb.coverage" NAME="cap_comb Coverage Results" MODIFIED="1617061966686" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/cap_map$test.coverage" NAME="test Coverage Results" MODIFIED="1617400844835" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/cap_map$cap_comb.coverage" NAME="cap_comb Coverage Results" MODIFIED="1620814832982" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
   </component>
 </project>
\ No newline at end of file
