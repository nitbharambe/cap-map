Index: cap/viz.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python\r\n# coding: utf-8\r\n\r\n# ### 1. preprocessing the data\r\n\r\n# In[5]:\r\n\r\n\r\n# power flow package & python package ( edited by Joe )\r\nfrom cap import pfa\r\nimport copy\r\nimport pandas as pd\r\n\r\n# Dash import\r\nimport pandas as pd\r\nimport plotly.express as px  # (version 4.7.0)\r\nimport plotly.graph_objects as go\r\n\r\nimport dash  # (version 1.12.0) pip install dash\r\nimport dash_core_components as dcc\r\nimport dash_html_components as html\r\nfrom dash.dependencies import Input, Output\r\n\r\n# panda package\r\nfrom pandapower.plotting.plotly import pf_res_plotly\r\nimport numpy as np\r\n\r\n# for copy panda object\r\nfrom copy import deepcopy\r\n\r\n# for editing the draw_trace() function\r\nfrom pandapower.plotting.plotly import traces\r\nfrom pandapower.plotting.plotly.traces import _in_ipynb\r\n\r\nimport math\r\n\r\nfrom packaging import version\r\nfrom collections.abc import Iterable\r\n\r\nfrom pandapower.plotting.plotly.get_colors import get_plotly_color, get_plotly_cmap\r\nfrom pandapower.plotting.plotly.mapbox_plot import _on_map_test, _get_mapbox_token,     MapboxTokenMissing\r\n\r\ntry:\r\n    from plotly import __version__ as plotly_version\r\n    from plotly.graph_objs.scatter.marker import ColorBar\r\n    from plotly.graph_objs import Figure, Layout\r\n    from plotly.graph_objs.layout import XAxis, YAxis\r\n    from plotly.graph_objs.scatter import Line, Marker\r\n    from plotly.graph_objs.scattermapbox import Line as scmLine\r\n    from plotly.graph_objs.scattermapbox import Marker as scmMarker\r\nexcept ImportError:\r\n    logger.info(\"Failed to import plotly - interactive plotting will not be available\")\r\n\r\n# changing the function part (edited by Daniel)\r\n# import pandas as pd \r\nfrom pandapower.plotting.generic_geodata import create_generic_coordinates\r\nfrom pandapower.plotting.plotly.mapbox_plot import *\r\nfrom pandapower.plotting.plotly.traces import create_bus_trace, create_line_trace,     create_trafo_trace, draw_traces, version_check\r\nfrom pandapower.run import runpp\r\n \r\ntry:\r\n    import pplog as logging\r\nexcept ImportError:\r\n    import logging\r\nlogger = logging.getLogger(__name__)\r\n\r\n\r\n# In[2]:\r\n\r\n\r\n# Edited function res_plotly() and draw_traces()\r\n\r\ndef draw_traces1(traces, on_map=False, map_style='basic', showlegend=True, figsize=1,\r\n                aspectratio='auto', filename='temp-plot.html'):\r\n    \"\"\"\r\n    plots all the traces (which can be created using :func:`create_bus_trace`, :func:`create_line_trace`,\r\n    :func:`create_trafo_trace`)\r\n    to PLOTLY (see https://plot.ly/python/)\r\n\r\n    INPUT:\r\n        **traces** - list of dicts which correspond to plotly traces\r\n        generated using: `create_bus_trace`, `create_line_trace`, `create_trafo_trace`\r\n\r\n    OPTIONAL:\r\n        **on_map** (bool, False) - enables using mapbox plot in plotly\r\n\r\n        **map_style** (str, 'basic') - enables using mapbox plot in plotly\r\n\r\n            - 'streets'\r\n            - 'bright'\r\n            - 'light'\r\n            - 'dark'\r\n            - 'satellite'\r\n\r\n        **showlegend** (bool, 'True') - enables legend display\r\n\r\n        **figsize** (float, 1) - aspectratio is multiplied by it in order to get final image size\r\n\r\n        **aspectratio** (tuple, 'auto') - when 'auto' it preserves original aspect ratio of the\r\n            network geodata any custom aspectration can be given as a tuple, e.g. (1.2, 1)\r\n\r\n        **filename** (str, \"temp-plot.html\") - plots to a html file called filename\r\n\r\n    OUTPUT:\r\n        **figure** (graph_objs._figure.Figure) figure object\r\n\r\n    \"\"\"\r\n\r\n    if on_map:\r\n        try:\r\n            on_map = _on_map_test(traces[0]['x'][0], traces[0]['y'][0])\r\n        except:\r\n            logger.warning(\"Test if geo-data are in lat/long cannot be performed using geopy -> \"\r\n                           \"eventual plot errors are possible.\")\r\n\r\n        if on_map is False:\r\n            logger.warning(\"Existing geodata are not real lat/lon geographical coordinates. -> \"\r\n                           \"plot on maps is not possible.\\n\"\r\n                           \"Use geo_data_to_latlong(net, projection) to transform geodata from specific projection.\")\r\n\r\n    if on_map:\r\n        # change traces for mapbox\r\n        # change trace_type to scattermapbox and rename x to lat and y to lon\r\n        for trace in traces:\r\n            trace['lat'] = trace.pop('x')\r\n            trace['lon'] = trace.pop('y')\r\n            trace['type'] = 'scattermapbox'\r\n            if \"line\" in trace and isinstance(trace[\"line\"], Line):\r\n                # scattermapboxplot lines do not support dash for some reason, make it a red line instead\r\n                if \"dash\" in trace[\"line\"]._props:\r\n                    _prps = dict(trace[\"line\"]._props)\r\n                    _prps.pop(\"dash\", None)\r\n                    _prps[\"color\"] = \"red\"\r\n                    trace[\"line\"] = scmLine(_prps)\r\n                else:\r\n                    trace[\"line\"] = scmLine(dict(trace[\"line\"]._props))\r\n            elif \"marker\" in trace and isinstance(trace[\"marker\"], Marker):\r\n                trace[\"marker\"] = scmMarker(trace[\"marker\"]._props)\r\n\r\n    # setting Figure object\r\n    fig = Figure(data=traces,  # edge_trace\r\n                 layout=Layout(\r\n                     titlefont=dict(size=16),\r\n                     showlegend=showlegend,\r\n                     autosize=(aspectratio == 'auto'),\r\n                     hovermode='closest',\r\n                     margin=dict(b=5, l=5, r=5, t=5),\r\n                     # annotations=[dict(\r\n                     #     text=\"\",\r\n                     #     showarrow=False,\r\n                     #     xref=\"paper\", yref=\"paper\",\r\n                     #     x=0.005, y=-0.002)],\r\n                     xaxis=XAxis(showgrid=False, zeroline=False, showticklabels=False),\r\n                     yaxis=YAxis(showgrid=False, zeroline=False, showticklabels=False),\r\n                     # legend=dict(x=0, y=1.0)\r\n                 ), )\r\n\r\n    # check if geodata are real geographical lat/lon coordinates using geopy\r\n\r\n    if on_map:\r\n        try:\r\n            mapbox_access_token = _get_mapbox_token()\r\n        except Exception:\r\n            logger.exception('mapbox token required for map plots. '\r\n                             'Get Mapbox token by signing in to https://www.mapbox.com/.\\n'\r\n                             'After getting a token, set it to pandapower using:\\n'\r\n                             'pandapower.plotting.plotly.mapbox_plot.set_mapbox_token(\\'<token>\\')')\r\n            raise MapboxTokenMissing\r\n\r\n        fig['layout']['mapbox'] = dict(accesstoken=mapbox_access_token,\r\n                                       bearing=0,\r\n                                       center=dict(lat=pd.Series(traces[0]['lat']).dropna().mean(),\r\n                                                   lon=pd.Series(traces[0]['lon']).dropna().mean()),\r\n                                       style=map_style,\r\n                                       pitch=0,\r\n                                       zoom=11)\r\n\r\n    # default aspectratio: if on_map use auto, else use 'original'\r\n    aspectratio = 'original' if not on_map and aspectratio == 'auto' else aspectratio\r\n\r\n    if aspectratio != 'auto':\r\n        if aspectratio == 'original':\r\n            # TODO improve this workaround for getting original aspectratio\r\n            xs = []\r\n            ys = []\r\n            for trace in traces:\r\n                xs += trace['x']\r\n                ys += trace['y']\r\n            x_dropna = pd.Series(xs).dropna()\r\n            y_dropna = pd.Series(ys).dropna()\r\n            xrange = x_dropna.max() - x_dropna.min()\r\n            yrange = y_dropna.max() - y_dropna.min()\r\n            ratio = xrange / yrange\r\n            if ratio < 1:\r\n                aspectratio = (ratio, 1.)\r\n            else:\r\n                aspectratio = (1., 1 / ratio)\r\n\r\n        aspectratio = np.array(aspectratio) / max(aspectratio)\r\n        fig['layout']['width'], fig['layout']['height'] = ([ar * figsize * 700 for ar in aspectratio])\r\n\r\n    # check if called from ipynb or not in order to consider appropriate plot function\r\n    if _in_ipynb():\r\n        from plotly.offline import init_notebook_mode, iplot as plot\r\n        init_notebook_mode()\r\n    else:\r\n        from plotly.offline import plot as plot\r\n\r\n    # delete the plot function here.\r\n    # plot(fig, filename=filename)\r\n\r\n    return fig\r\n\r\n\r\n\r\ndef pf_res_plotly1(net, cmap=\"Jet\", use_line_geodata=None, on_map=False, projection=None,\r\n                  map_style='basic', figsize=1, aspectratio='auto', line_width=2, bus_size=10,\r\n                  climits_volt=(0.9, 1.1), climits_load=(0, 100), cpos_volt=1.0, cpos_load=1.1,\r\n                  filename=\"temp-plot.html\"):\r\n    \"\"\"\r\n    Plots a pandapower network in plotly\r\n    using colormap for coloring lines according to line loading and buses according to voltage in p.u.\r\n    If no geodata is available, artificial geodata is generated. For advanced plotting see the tutorial\r\n \r\n    INPUT:\r\n        **net** - The pandapower format network. If none is provided, mv_oberrhein() will be\r\n        plotted as an example\r\n \r\n    OPTIONAL:\r\n        **respect_switches** (bool, False) - Respect switches when artificial geodata is created\r\n \r\n        *cmap** (str, True) - name of the colormap\r\n \r\n        *colors_dict** (dict, None) - by default 6 basic colors from default collor palette is used.\r\n        Otherwise, user can define a dictionary in the form: voltage_kv : color\r\n \r\n        **on_map** (bool, False) - enables using mapbox plot in plotly\r\n        If provided geodata are not real geo-coordinates in lon/lat form, on_map will be set to False.\r\n \r\n        **projection** (String, None) - defines a projection from which network geo-data will be transformed to\r\n        lat-long. For each projection a string can be found at http://spatialreference.org/ref/epsg/\r\n \r\n        **map_style** (str, 'basic') - enables using mapbox plot in plotly\r\n \r\n            - 'streets'\r\n            - 'bright'\r\n            - 'light'\r\n            - 'dark'\r\n            - 'satellite'\r\n \r\n        **figsize** (float, 1) - aspectratio is multiplied by it in order to get final image size\r\n \r\n        **aspectratio** (tuple, 'auto') - when 'auto' it preserves original aspect ratio of the network geodata\r\n        any custom aspectration can be given as a tuple, e.g. (1.2, 1)\r\n \r\n        **line_width** (float, 1.0) - width of lines\r\n \r\n        **bus_size** (float, 10.0) -  size of buses to plot.\r\n \r\n        **climits_volt** (tuple, (0.9, 1.0)) - limits of the colorbar for voltage\r\n \r\n        **climits_load** (tuple, (0, 100)) - limits of the colorbar for line_loading\r\n \r\n        **cpos_volt** (float, 1.0) - position of the bus voltage colorbar\r\n \r\n        **cpos_load** (float, 1.1) - position of the loading percent colorbar\r\n \r\n        **filename** (str, \"temp-plot.html\") - filename / path to plot to. Should end on *.html\r\n \r\n    OUTPUT:\r\n        **figure** (graph_objs._figure.Figure) figure object\r\n \r\n    \"\"\"\r\n    version_check()\r\n    if 'res_bus' not in net or net.get('res_bus').shape[0] == 0:\r\n        logger.warning('There are no Power Flow results. A Newton-Raphson power flow will be executed.')\r\n        runpp(net)\r\n \r\n    # create geocoord if none are available\r\n    if 'line_geodata' not in net:\r\n        net.line_geodata = pd.DataFrame(columns=['coords'])\r\n    if 'bus_geodata' not in net:\r\n        net.bus_geodata = pd.DataFrame(columns=[\"x\", \"y\"])\r\n    if len(net.line_geodata) == 0 and len(net.bus_geodata) == 0:\r\n        logger.warning(\"No or insufficient geodata available --> Creating artificial coordinates.\" +\r\n                       \" This may take some time\")\r\n        create_generic_coordinates(net, respect_switches=True)\r\n        if on_map:\r\n            logger.warning(\"Map plots not available with artificial coordinates and will be disabled!\")\r\n            on_map = False\r\n \r\n    # check if geodata are real geographycal lat/lon coordinates using geopy\r\n    if on_map and projection is not None:\r\n        geo_data_to_latlong(net, projection=projection)\r\n \r\n    # ----- Buses ------\r\n    # initializating bus trace\r\n    # hoverinfo which contains name and pf results\r\n    precision = 3\r\n    hoverinfo = (\r\n            net.bus.name.astype(str) + '<br />' +\r\n            'V_m = ' + net.res_bus.vm_pu.round(precision).astype(str) + 'pu' + '<br />' +\r\n            'V_m = ' + (net.res_bus.vm_pu * net.bus.vn_kv.round(2)).round(precision).astype(str) + ' kV' + '<br />' +\r\n            'Max_cap =' + net.load.max_load.astype(str) + 'MW' + '<br />' +\r\n            'V_a = ' + net.res_bus.va_degree.round(precision).astype(str) + ' deg').tolist()\r\n    hoverinfo = pd.Series(index=net.bus.index, data=hoverinfo)\r\n    bus_trace = create_bus_trace(net, net.bus.index, size=bus_size, infofunc=hoverinfo, cmap=cmap,\r\n                                 cbar_title='Bus Voltage [pu]', cmin=climits_volt[0], cmax=climits_volt[1],\r\n                                 cpos=cpos_volt)\r\n \r\n    # ----- Lines ------\r\n    # if bus geodata is available, but no line geodata\r\n    # if bus geodata is available, but no line geodata\r\n    cmap_lines = 'jet' if cmap == 'Jet' else cmap\r\n    if use_line_geodata is None:\r\n        use_line_geodata = False if len(net.line_geodata) == 0 else True\r\n    elif use_line_geodata and len(net.line_geodata) == 0:\r\n        logger.warning(\"No or insufficient line geodata available --> only bus geodata will be used.\")\r\n        use_line_geodata = False\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (\r\n            net.line.name.astype(str) + '<br />' +\r\n            'I = ' + net.res_line.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            'I_from = ' + net.res_line.i_from_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            'I_to = ' + net.res_line.i_to_ka.round(precision).astype(str) + ' kA' + '<br />').tolist()\r\n    hoverinfo = pd.Series(index=net.line.index, data=hoverinfo)\r\n    line_traces = create_line_trace(net, use_line_geodata=use_line_geodata, respect_switches=True,\r\n                                    width=line_width,\r\n                                    infofunc=hoverinfo,\r\n                                    cmap=cmap_lines,\r\n                                    cmap_vals=net.res_line['loading_percent'].values,\r\n                                    cmin=climits_load[0],\r\n                                    cmax=climits_load[1],\r\n                                    cbar_title='Line Loading [%]',\r\n                                    cpos=cpos_load)\r\n \r\n    # ----- Trafos ------\r\n    # hoverinfo which contains name and pf results\r\n    hoverinfo = (\r\n            net.trafo.name.astype(str) + '<br />' +\r\n            'I = ' + net.res_trafo.loading_percent.round(precision).astype(str) + ' %' + '<br />' +\r\n            'I_hv = ' + net.res_trafo.i_hv_ka.round(precision).astype(str) + ' kA' + '<br />' +\r\n            'I_lv = ' + net.res_trafo.i_lv_ka.round(precision).astype(str) + ' kA' + '<br />').tolist()\r\n    hoverinfo = pd.Series(index=net.trafo.index, data=hoverinfo)\r\n    trafo_traces = create_trafo_trace(net, width=line_width * 1.5, infofunc=hoverinfo,\r\n                                      cmap=cmap_lines, cmin=0, cmax=100)\r\n \r\n    # ----- Ext grid ------\r\n    # get external grid from create_bus_trace\r\n    marker_type = 'circle' if on_map else 'square'\r\n    ext_grid_trace = create_bus_trace(net, buses=net.ext_grid.bus,\r\n                                      color='grey', size=bus_size * 2, trace_name='external_grid',\r\n                                      patch_type=marker_type)\r\n \r\n    return draw_traces1(line_traces + trafo_traces + ext_grid_trace + bus_trace,\r\n                       showlegend=False, aspectratio=aspectratio, on_map=on_map,\r\n                       map_style=map_style, figsize=figsize, filename=filename)\r\n\r\n\r\n# In[3]:\r\n\r\n\r\n\r\n\"\"\" \r\n\r\nExtract data from time-series calculation. With result[0] being the vm_pu, result[1] being line_load, result[2] being trafo_loading_percent\r\n\r\nReturn two list, networks & figures. Which will be later used for Dash.\r\n\r\n Some points here: \r\n1. the time series loop through columns instead of rows. This is dealt in the two loop structure down below.\r\n\r\n\"\"\"\r\n\r\ndef generate_graph_data(net):\r\n    net = net\r\n    result = pfa.load_files()\r\n\r\n    # create lists for time-series data, networks for net, figures for fig\r\n    networks = [None]*len(result[0])\r\n    figures = [None]*len(result[0])\r\n\r\n    # looping to get the time-series data into the list ( i = number(timeseries) networks)\r\n    for i in np.arange(len(result[0])):\r\n        \r\n        # here iterate through res_bus.vm_pu, ( result[0] )\r\n        for j in np.arange(len(result[0].columns)):\r\n            net.res_bus.vm_pu[j] = result[0][j][i]\r\n        \r\n        # here iterate through res_line.loading_percent, ( result[1] )\r\n        for k in np.arange(len(result[1].columns)):\r\n            net.res_line.loading_percent[k] = result[1][k][i]\r\n        \r\n        # here iterate through res_trafo.loading_percent, ( result[2] )\r\n        for l in np.arange(len(result[2].columns)):\r\n            net.res_trafo.loading_percent[l] = result[2][l][i]\r\n        \r\n        networks[i] = deepcopy(net)\r\n\r\n    #looping to get the time series graph\r\n    for ii in np.arange(len(networks)):\r\n        figures[ii] = deepcopy(pf_res_plotly1(networks[ii],map_style='dark'))\r\n        \r\n    return networks, figures\r\n\r\n\r\n# ### 2. Generate the grpah with Dash\r\n\r\n# In[4]:\r\n\r\n\r\n\"\"\"\r\n\r\nGenerate Dash graph. Calling this function along is enough for generating the grapgh.\r\n\r\nreturn a link to the Dash site.\r\n\r\n\"\"\"\r\n\r\ndef generate_graph(input_data, time):\r\n    net = input_data\r\n    time_steps = time\r\n    \r\n    networks = [None]*len(net.res_bus.vm_pu)\r\n    figures = [None]*len(time_steps)\r\n    # extract time-series values\r\n    networks, figures = generate_graph_data(net)\r\n    \r\n    # take the correct order for slider\r\n    list_length = len(networks)-1\r\n\r\n    app = dash.Dash(__name__)\r\n\r\n    # ------------------------------------------------------------------------------\r\n    # App layout\r\n    app.layout = html.Div([\r\n\r\n        html.H1(\"Capacity Map with Dash component Testing\", style={'text-align': 'center'}),\r\n\r\n        dcc.Dropdown(id=\"slct_year\",\r\n                     options=[\r\n                         {\"label\": \"2015\", \"value\": 2015},\r\n                         {\"label\": \"2016\", \"value\": 2016},\r\n                         {\"label\": \"2017\", \"value\": 2017},\r\n                         {\"label\": \"2018\", \"value\": 2018}],\r\n                     multi=False,\r\n                     value=2015,\r\n                     style={'width': \"40%\"}\r\n                     ),\r\n\r\n        html.Br(),\r\n\r\n        dcc.Graph(id='my_powerFlow_graph',\r\n                  style={\r\n                      \"margin-left\": \"auto\",\r\n                      \"margin-right\": \"auto\",\r\n                  },\r\n                  figure={}),\r\n        html.Div(id='output_container_slider', children=[]),\r\n        html.Br(),\r\n\r\n        dcc.Slider(\r\n            id='my-slider',\r\n            min=0,\r\n            max=list_length,\r\n            step=1,\r\n            value=1,\r\n        ),\r\n\r\n    ],\r\n        # putting Style for the whole html.div block and it works!!!\r\n    style={'width': '50%','padding-left':'25%', 'padding-right':'25%'},\r\n    )\r\n\r\n\r\n    # ------------------------------------------------------------------------------\r\n    # Connect the Plotly graphs with Dash Components\r\n    @app.callback(\r\n        [Output(component_id='output_container_slider', component_property='children'),\r\n         Output(component_id='my_powerFlow_graph', component_property='figure')],\r\n        [Input(component_id='slct_year', component_property='value'),\r\n         Input(component_id = 'my-slider',component_property='value')]\r\n    )\r\n    def update_graph(option_slctd, slider_slctd):\r\n        print(option_slctd)\r\n        print(type(option_slctd))\r\n\r\n        container = \"The year chosen by user was: {}\".format(option_slctd)\r\n        container_slider = \"The time chosen by user was: {}\".format(slider_slctd)\r\n\r\n        fig_power = figures[slider_slctd]\r\n\r\n        # 上面的output對應到這邊的return，是按照順序的\r\n        # The output is correspoding to the return value below, by order\r\n        return container_slider, fig_power\r\n\r\n\r\n    # ------------------------------------------------------------------------------\r\n    if __name__ == '__main__':\r\n        return app.run_server(debug=True,use_reloader=False,port=3004)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cap/viz.py b/cap/viz.py
--- a/cap/viz.py	
+++ b/cap/viz.py	
@@ -382,7 +382,6 @@
 
     # looping to get the time-series data into the list ( i = number(timeseries) networks)
     for i in np.arange(len(result[0])):
-        
         # here iterate through res_bus.vm_pu, ( result[0] )
         for j in np.arange(len(result[0].columns)):
             net.res_bus.vm_pu[j] = result[0][j][i]
